# encoding: utf-8
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module UrlModule
  #
  # Test Infrastructure for AutoRest
  #
  class Queries

    #
    # Creates and initializes a new instance of the Queries class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [AutoRestUrlTestService] reference to the AutoRestUrlTestService
    attr_reader :client

    #
    # Get true Boolean value on path
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_boolean_true(custom_headers = nil)
      response = get_boolean_true_async(custom_headers).value!
      nil
    end

    #
    # Get true Boolean value on path
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_boolean_true_with_http_info(custom_headers = nil)
      get_boolean_true_async(custom_headers).value!
    end

    #
    # Get true Boolean value on path
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_boolean_true_async(custom_headers = nil)
      bool_query = true


      request_headers = {}
      path_template = 'queries/bool/true'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'boolQuery' => bool_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get false Boolean value on path
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_boolean_false(custom_headers = nil)
      response = get_boolean_false_async(custom_headers).value!
      nil
    end

    #
    # Get false Boolean value on path
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_boolean_false_with_http_info(custom_headers = nil)
      get_boolean_false_async(custom_headers).value!
    end

    #
    # Get false Boolean value on path
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_boolean_false_async(custom_headers = nil)
      bool_query = false


      request_headers = {}
      path_template = 'queries/bool/false'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'boolQuery' => bool_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null Boolean value on query (query string should be absent)
    #
    # @param bool_query [Boolean] null boolean value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_boolean_null(bool_query = nil, custom_headers = nil)
      response = get_boolean_null_async(bool_query, custom_headers).value!
      nil
    end

    #
    # Get null Boolean value on query (query string should be absent)
    #
    # @param bool_query [Boolean] null boolean value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_boolean_null_with_http_info(bool_query = nil, custom_headers = nil)
      get_boolean_null_async(bool_query, custom_headers).value!
    end

    #
    # Get null Boolean value on query (query string should be absent)
    #
    # @param bool_query [Boolean] null boolean value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_boolean_null_async(bool_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/bool/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'boolQuery' => bool_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '1000000' integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_int_one_million(custom_headers = nil)
      response = get_int_one_million_async(custom_headers).value!
      nil
    end

    #
    # Get '1000000' integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_int_one_million_with_http_info(custom_headers = nil)
      get_int_one_million_async(custom_headers).value!
    end

    #
    # Get '1000000' integer value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_int_one_million_async(custom_headers = nil)
      int_query = 1000000


      request_headers = {}
      path_template = 'queries/int/1000000'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'intQuery' => int_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '-1000000' integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_int_negative_one_million(custom_headers = nil)
      response = get_int_negative_one_million_async(custom_headers).value!
      nil
    end

    #
    # Get '-1000000' integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_int_negative_one_million_with_http_info(custom_headers = nil)
      get_int_negative_one_million_async(custom_headers).value!
    end

    #
    # Get '-1000000' integer value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_int_negative_one_million_async(custom_headers = nil)
      int_query = -1000000


      request_headers = {}
      path_template = 'queries/int/-1000000'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'intQuery' => int_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null integer value (no query parameter)
    #
    # @param int_query [Integer] null integer value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_int_null(int_query = nil, custom_headers = nil)
      response = get_int_null_async(int_query, custom_headers).value!
      nil
    end

    #
    # Get null integer value (no query parameter)
    #
    # @param int_query [Integer] null integer value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_int_null_with_http_info(int_query = nil, custom_headers = nil)
      get_int_null_async(int_query, custom_headers).value!
    end

    #
    # Get null integer value (no query parameter)
    #
    # @param int_query [Integer] null integer value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_int_null_async(int_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/int/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'intQuery' => int_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '10000000000' 64 bit integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_ten_billion(custom_headers = nil)
      response = get_ten_billion_async(custom_headers).value!
      nil
    end

    #
    # Get '10000000000' 64 bit integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_ten_billion_with_http_info(custom_headers = nil)
      get_ten_billion_async(custom_headers).value!
    end

    #
    # Get '10000000000' 64 bit integer value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_ten_billion_async(custom_headers = nil)
      long_query = 10000000000


      request_headers = {}
      path_template = 'queries/long/10000000000'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'longQuery' => long_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '-10000000000' 64 bit integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_negative_ten_billion(custom_headers = nil)
      response = get_negative_ten_billion_async(custom_headers).value!
      nil
    end

    #
    # Get '-10000000000' 64 bit integer value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_negative_ten_billion_with_http_info(custom_headers = nil)
      get_negative_ten_billion_async(custom_headers).value!
    end

    #
    # Get '-10000000000' 64 bit integer value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_negative_ten_billion_async(custom_headers = nil)
      long_query = -10000000000


      request_headers = {}
      path_template = 'queries/long/-10000000000'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'longQuery' => long_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get 'null 64 bit integer value (no query param in uri)
    #
    # @param long_query [Integer] null 64 bit integer value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def get_long_null(long_query = nil, custom_headers = nil)
      response = get_long_null_async(long_query, custom_headers).value!
      nil
    end

    #
    # Get 'null 64 bit integer value (no query param in uri)
    #
    # @param long_query [Integer] null 64 bit integer value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_long_null_with_http_info(long_query = nil, custom_headers = nil)
      get_long_null_async(long_query, custom_headers).value!
    end

    #
    # Get 'null 64 bit integer value (no query param in uri)
    #
    # @param long_query [Integer] null 64 bit integer value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_long_null_async(long_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/long/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'longQuery' => long_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '1.034E+20' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def float_scientific_positive(custom_headers = nil)
      response = float_scientific_positive_async(custom_headers).value!
      nil
    end

    #
    # Get '1.034E+20' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def float_scientific_positive_with_http_info(custom_headers = nil)
      float_scientific_positive_async(custom_headers).value!
    end

    #
    # Get '1.034E+20' numeric value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def float_scientific_positive_async(custom_headers = nil)
      float_query = 103400000000000000000


      request_headers = {}
      path_template = 'queries/float/1.034E+20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'floatQuery' => float_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '-1.034E-20' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def float_scientific_negative(custom_headers = nil)
      response = float_scientific_negative_async(custom_headers).value!
      nil
    end

    #
    # Get '-1.034E-20' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def float_scientific_negative_with_http_info(custom_headers = nil)
      float_scientific_negative_async(custom_headers).value!
    end

    #
    # Get '-1.034E-20' numeric value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def float_scientific_negative_async(custom_headers = nil)
      float_query = -1.034e-20


      request_headers = {}
      path_template = 'queries/float/-1.034E-20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'floatQuery' => float_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null numeric value (no query parameter)
    #
    # @param float_query [Float] null numeric value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def float_null(float_query = nil, custom_headers = nil)
      response = float_null_async(float_query, custom_headers).value!
      nil
    end

    #
    # Get null numeric value (no query parameter)
    #
    # @param float_query [Float] null numeric value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def float_null_with_http_info(float_query = nil, custom_headers = nil)
      float_null_async(float_query, custom_headers).value!
    end

    #
    # Get null numeric value (no query parameter)
    #
    # @param float_query [Float] null numeric value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def float_null_async(float_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/float/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'floatQuery' => float_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '9999999.999' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def double_decimal_positive(custom_headers = nil)
      response = double_decimal_positive_async(custom_headers).value!
      nil
    end

    #
    # Get '9999999.999' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def double_decimal_positive_with_http_info(custom_headers = nil)
      double_decimal_positive_async(custom_headers).value!
    end

    #
    # Get '9999999.999' numeric value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def double_decimal_positive_async(custom_headers = nil)
      double_query = 9999999.999


      request_headers = {}
      path_template = 'queries/double/9999999.999'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'doubleQuery' => double_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '-9999999.999' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def double_decimal_negative(custom_headers = nil)
      response = double_decimal_negative_async(custom_headers).value!
      nil
    end

    #
    # Get '-9999999.999' numeric value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def double_decimal_negative_with_http_info(custom_headers = nil)
      double_decimal_negative_async(custom_headers).value!
    end

    #
    # Get '-9999999.999' numeric value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def double_decimal_negative_async(custom_headers = nil)
      double_query = -9999999.999


      request_headers = {}
      path_template = 'queries/double/-9999999.999'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'doubleQuery' => double_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null numeric value (no query parameter)
    #
    # @param double_query [Float] null numeric value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def double_null(double_query = nil, custom_headers = nil)
      response = double_null_async(double_query, custom_headers).value!
      nil
    end

    #
    # Get null numeric value (no query parameter)
    #
    # @param double_query [Float] null numeric value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def double_null_with_http_info(double_query = nil, custom_headers = nil)
      double_null_async(double_query, custom_headers).value!
    end

    #
    # Get null numeric value (no query parameter)
    #
    # @param double_query [Float] null numeric value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def double_null_async(double_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/double/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'doubleQuery' => double_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def string_unicode(custom_headers = nil)
      response = string_unicode_async(custom_headers).value!
      nil
    end

    #
    # Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def string_unicode_with_http_info(custom_headers = nil)
      string_unicode_async(custom_headers).value!
    end

    #
    # Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def string_unicode_async(custom_headers = nil)
      string_query = '啊齄丂狛狜隣郎隣兀﨩'


      request_headers = {}
      path_template = 'queries/string/unicode/'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'stringQuery' => string_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get 'begin!*'();:@ &=+$,/?#[]end
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def string_url_encoded(custom_headers = nil)
      response = string_url_encoded_async(custom_headers).value!
      nil
    end

    #
    # Get 'begin!*'();:@ &=+$,/?#[]end
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def string_url_encoded_with_http_info(custom_headers = nil)
      string_url_encoded_async(custom_headers).value!
    end

    #
    # Get 'begin!*'();:@ &=+$,/?#[]end
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def string_url_encoded_async(custom_headers = nil)
      string_query = 'begin!*\'();:@ &=+$,/?#[]end'


      request_headers = {}
      path_template = 'queries/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'stringQuery' => string_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get ''
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def string_empty(custom_headers = nil)
      response = string_empty_async(custom_headers).value!
      nil
    end

    #
    # Get ''
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def string_empty_with_http_info(custom_headers = nil)
      string_empty_async(custom_headers).value!
    end

    #
    # Get ''
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def string_empty_async(custom_headers = nil)
      string_query = ''


      request_headers = {}
      path_template = 'queries/string/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'stringQuery' => string_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null (no query parameter in url)
    #
    # @param string_query [String] null string value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def string_null(string_query = nil, custom_headers = nil)
      response = string_null_async(string_query, custom_headers).value!
      nil
    end

    #
    # Get null (no query parameter in url)
    #
    # @param string_query [String] null string value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def string_null_with_http_info(string_query = nil, custom_headers = nil)
      string_null_async(string_query, custom_headers).value!
    end

    #
    # Get null (no query parameter in url)
    #
    # @param string_query [String] null string value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def string_null_async(string_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/string/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'stringQuery' => string_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get using uri with query parameter 'green color'
    #
    # @param enum_query [UriColor] 'green color' enum value. Possible values
    # include: 'red color', 'green color', 'blue color'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def enum_valid(enum_query = nil, custom_headers = nil)
      response = enum_valid_async(enum_query, custom_headers).value!
      nil
    end

    #
    # Get using uri with query parameter 'green color'
    #
    # @param enum_query [UriColor] 'green color' enum value. Possible values
    # include: 'red color', 'green color', 'blue color'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def enum_valid_with_http_info(enum_query = nil, custom_headers = nil)
      enum_valid_async(enum_query, custom_headers).value!
    end

    #
    # Get using uri with query parameter 'green color'
    #
    # @param enum_query [UriColor] 'green color' enum value. Possible values
    # include: 'red color', 'green color', 'blue color'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def enum_valid_async(enum_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/enum/green%20color'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'enumQuery' => enum_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null (no query parameter in url)
    #
    # @param enum_query [UriColor] null string value. Possible values include: 'red
    # color', 'green color', 'blue color'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def enum_null(enum_query = nil, custom_headers = nil)
      response = enum_null_async(enum_query, custom_headers).value!
      nil
    end

    #
    # Get null (no query parameter in url)
    #
    # @param enum_query [UriColor] null string value. Possible values include: 'red
    # color', 'green color', 'blue color'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def enum_null_with_http_info(enum_query = nil, custom_headers = nil)
      enum_null_async(enum_query, custom_headers).value!
    end

    #
    # Get null (no query parameter in url)
    #
    # @param enum_query [UriColor] null string value. Possible values include: 'red
    # color', 'green color', 'blue color'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def enum_null_async(enum_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/enum/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'enumQuery' => enum_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
    #
    # @param byte_query [Array<Integer>] '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8
    # encoded byte array
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def byte_multi_byte(byte_query = nil, custom_headers = nil)
      response = byte_multi_byte_async(byte_query, custom_headers).value!
      nil
    end

    #
    # Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
    #
    # @param byte_query [Array<Integer>] '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8
    # encoded byte array
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def byte_multi_byte_with_http_info(byte_query = nil, custom_headers = nil)
      byte_multi_byte_async(byte_query, custom_headers).value!
    end

    #
    # Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
    #
    # @param byte_query [Array<Integer>] '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8
    # encoded byte array
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def byte_multi_byte_async(byte_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/byte/multibyte'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'byteQuery' => byte_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '' as byte array
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def byte_empty(custom_headers = nil)
      response = byte_empty_async(custom_headers).value!
      nil
    end

    #
    # Get '' as byte array
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def byte_empty_with_http_info(custom_headers = nil)
      byte_empty_async(custom_headers).value!
    end

    #
    # Get '' as byte array
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def byte_empty_async(custom_headers = nil)
      byte_query = ''.bytes.pack('C*')


      request_headers = {}
      path_template = 'queries/byte/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'byteQuery' => byte_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null as byte array (no query parameters in uri)
    #
    # @param byte_query [Array<Integer>] null as byte array (no query parameters in
    # uri)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def byte_null(byte_query = nil, custom_headers = nil)
      response = byte_null_async(byte_query, custom_headers).value!
      nil
    end

    #
    # Get null as byte array (no query parameters in uri)
    #
    # @param byte_query [Array<Integer>] null as byte array (no query parameters in
    # uri)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def byte_null_with_http_info(byte_query = nil, custom_headers = nil)
      byte_null_async(byte_query, custom_headers).value!
    end

    #
    # Get null as byte array (no query parameters in uri)
    #
    # @param byte_query [Array<Integer>] null as byte array (no query parameters in
    # uri)
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def byte_null_async(byte_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/byte/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'byteQuery' => byte_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '2012-01-01' as date
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def date_valid(custom_headers = nil)
      response = date_valid_async(custom_headers).value!
      nil
    end

    #
    # Get '2012-01-01' as date
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def date_valid_with_http_info(custom_headers = nil)
      date_valid_async(custom_headers).value!
    end

    #
    # Get '2012-01-01' as date
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def date_valid_async(custom_headers = nil)
      date_query = Date.parse('2012-01-01')


      request_headers = {}
      path_template = 'queries/date/2012-01-01'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'dateQuery' => date_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null as date - this should result in no query parameters in uri
    #
    # @param date_query [Date] null as date (no query parameters in uri)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def date_null(date_query = nil, custom_headers = nil)
      response = date_null_async(date_query, custom_headers).value!
      nil
    end

    #
    # Get null as date - this should result in no query parameters in uri
    #
    # @param date_query [Date] null as date (no query parameters in uri)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def date_null_with_http_info(date_query = nil, custom_headers = nil)
      date_null_async(date_query, custom_headers).value!
    end

    #
    # Get null as date - this should result in no query parameters in uri
    #
    # @param date_query [Date] null as date (no query parameters in uri)
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def date_null_async(date_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/date/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'dateQuery' => date_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get '2012-01-01T01:01:01Z' as date-time
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def date_time_valid(custom_headers = nil)
      response = date_time_valid_async(custom_headers).value!
      nil
    end

    #
    # Get '2012-01-01T01:01:01Z' as date-time
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def date_time_valid_with_http_info(custom_headers = nil)
      date_time_valid_async(custom_headers).value!
    end

    #
    # Get '2012-01-01T01:01:01Z' as date-time
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def date_time_valid_async(custom_headers = nil)
      date_time_query = Date.parse('2012-01-01T01:01:01Z')


      request_headers = {}
      path_template = 'queries/datetime/2012-01-01T01%3A01%3A01Z'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'dateTimeQuery' => date_time_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get null as date-time, should result in no query parameters in uri
    #
    # @param date_time_query [DateTime] null as date-time (no query parameters)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def date_time_null(date_time_query = nil, custom_headers = nil)
      response = date_time_null_async(date_time_query, custom_headers).value!
      nil
    end

    #
    # Get null as date-time, should result in no query parameters in uri
    #
    # @param date_time_query [DateTime] null as date-time (no query parameters)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def date_time_null_with_http_info(date_time_query = nil, custom_headers = nil)
      date_time_null_async(date_time_query, custom_headers).value!
    end

    #
    # Get null as date-time, should result in no query parameters in uri
    #
    # @param date_time_query [DateTime] null as date-time (no query parameters)
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def date_time_null_async(date_time_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/datetime/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'dateTimeQuery' => date_time_query},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the csv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def array_string_csv_valid(array_query = nil, custom_headers = nil)
      response = array_string_csv_valid_async(array_query, custom_headers).value!
      nil
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the csv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def array_string_csv_valid_with_http_info(array_query = nil, custom_headers = nil)
      array_string_csv_valid_async(array_query, custom_headers).value!
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the csv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def array_string_csv_valid_async(array_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/array/csv/string/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'arrayQuery' => array_query.nil? ? nil : array_query.join(',')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get a null array of string using the csv-array format
    #
    # @param array_query [Array<String>] a null array of string using the csv-array
    # format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def array_string_csv_null(array_query = nil, custom_headers = nil)
      response = array_string_csv_null_async(array_query, custom_headers).value!
      nil
    end

    #
    # Get a null array of string using the csv-array format
    #
    # @param array_query [Array<String>] a null array of string using the csv-array
    # format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def array_string_csv_null_with_http_info(array_query = nil, custom_headers = nil)
      array_string_csv_null_async(array_query, custom_headers).value!
    end

    #
    # Get a null array of string using the csv-array format
    #
    # @param array_query [Array<String>] a null array of string using the csv-array
    # format
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def array_string_csv_null_async(array_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/array/csv/string/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'arrayQuery' => array_query.nil? ? nil : array_query.join(',')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get an empty array [] of string using the csv-array format
    #
    # @param array_query [Array<String>] an empty array [] of string using the
    # csv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def array_string_csv_empty(array_query = nil, custom_headers = nil)
      response = array_string_csv_empty_async(array_query, custom_headers).value!
      nil
    end

    #
    # Get an empty array [] of string using the csv-array format
    #
    # @param array_query [Array<String>] an empty array [] of string using the
    # csv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def array_string_csv_empty_with_http_info(array_query = nil, custom_headers = nil)
      array_string_csv_empty_async(array_query, custom_headers).value!
    end

    #
    # Get an empty array [] of string using the csv-array format
    #
    # @param array_query [Array<String>] an empty array [] of string using the
    # csv-array format
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def array_string_csv_empty_async(array_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/array/csv/string/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'arrayQuery' => array_query.nil? ? nil : array_query.join(',')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the ssv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the ssv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def array_string_ssv_valid(array_query = nil, custom_headers = nil)
      response = array_string_ssv_valid_async(array_query, custom_headers).value!
      nil
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the ssv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the ssv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def array_string_ssv_valid_with_http_info(array_query = nil, custom_headers = nil)
      array_string_ssv_valid_async(array_query, custom_headers).value!
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the ssv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the ssv-array format
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def array_string_ssv_valid_async(array_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/array/ssv/string/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'arrayQuery' => array_query.nil? ? nil : array_query.join(' ')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the tsv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the tsv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def array_string_tsv_valid(array_query = nil, custom_headers = nil)
      response = array_string_tsv_valid_async(array_query, custom_headers).value!
      nil
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the tsv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the tsv-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def array_string_tsv_valid_with_http_info(array_query = nil, custom_headers = nil)
      array_string_tsv_valid_async(array_query, custom_headers).value!
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the tsv-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the tsv-array format
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def array_string_tsv_valid_async(array_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/array/tsv/string/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'arrayQuery' => array_query.nil? ? nil : array_query.join('	')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the pipes-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the pipes-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def array_string_pipes_valid(array_query = nil, custom_headers = nil)
      response = array_string_pipes_valid_async(array_query, custom_headers).value!
      nil
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the pipes-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the pipes-array format
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def array_string_pipes_valid_with_http_info(array_query = nil, custom_headers = nil)
      array_string_pipes_valid_async(array_query, custom_headers).value!
    end

    #
    # Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null,
    # ''] using the pipes-array format
    #
    # @param array_query [Array<String>] an array of string ['ArrayQuery1',
    # 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the pipes-array format
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def array_string_pipes_valid_async(array_query = nil, custom_headers = nil)


      request_headers = {}
      path_template = 'queries/array/pipes/string/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'arrayQuery' => array_query.nil? ? nil : array_query.join('|')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

  end
end
