# encoding: utf-8
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module ArrayModule
  #
  # Test Infrastructure for AutoRest Swagger BAT
  #
  class Array

    #
    # Creates and initializes a new instance of the Array class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [AutoRestSwaggerBATArrayService] reference to the AutoRestSwaggerBATArrayService
    attr_reader :client

    #
    # Get null array value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_null(custom_headers = nil)
      response = get_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get null array value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_null_with_http_info(custom_headers = nil)
      get_null_async(custom_headers).value!
    end

    #
    # Get null array value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'NumberElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get invalid array [1, 2, 3
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_invalid(custom_headers = nil)
      response = get_invalid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get invalid array [1, 2, 3
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_invalid_with_http_info(custom_headers = nil)
      get_invalid_async(custom_headers).value!
    end

    #
    # Get invalid array [1, 2, 3
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_invalid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/invalid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'NumberElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get empty array value []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_empty(custom_headers = nil)
      response = get_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get empty array value []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_empty_with_http_info(custom_headers = nil)
      get_empty_async(custom_headers).value!
    end

    #
    # Get empty array value []
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'NumberElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value empty []
    #
    # @param array_body [Array<String>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_empty(array_body, custom_headers = nil)
      response = put_empty_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value empty []
    #
    # @param array_body [Array<String>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_empty_with_http_info(array_body, custom_headers = nil)
      put_empty_async(array_body, custom_headers).value!
    end

    #
    # Set array value empty []
    #
    # @param array_body [Array<String>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_empty_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'StringElementType',
              type: {
                name: 'String'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get boolean array value [true, false, false, true]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_boolean_tfft(custom_headers = nil)
      response = get_boolean_tfft_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get boolean array value [true, false, false, true]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_boolean_tfft_with_http_info(custom_headers = nil)
      get_boolean_tfft_async(custom_headers).value!
    end

    #
    # Get boolean array value [true, false, false, true]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_boolean_tfft_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/boolean/tfft'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'BooleanElementType',
                    type: {
                      name: 'Boolean'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value empty [true, false, false, true]
    #
    # @param array_body [Array<Boolean>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_boolean_tfft(array_body, custom_headers = nil)
      response = put_boolean_tfft_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value empty [true, false, false, true]
    #
    # @param array_body [Array<Boolean>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_boolean_tfft_with_http_info(array_body, custom_headers = nil)
      put_boolean_tfft_async(array_body, custom_headers).value!
    end

    #
    # Set array value empty [true, false, false, true]
    #
    # @param array_body [Array<Boolean>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_boolean_tfft_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'BooleanElementType',
              type: {
                name: 'Boolean'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/boolean/tfft'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get boolean array value [true, null, false]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_boolean_invalid_null(custom_headers = nil)
      response = get_boolean_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get boolean array value [true, null, false]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_boolean_invalid_null_with_http_info(custom_headers = nil)
      get_boolean_invalid_null_async(custom_headers).value!
    end

    #
    # Get boolean array value [true, null, false]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_boolean_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/boolean/true.null.false'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'BooleanElementType',
                    type: {
                      name: 'Boolean'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get boolean array value [true, 'boolean', false]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_boolean_invalid_string(custom_headers = nil)
      response = get_boolean_invalid_string_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get boolean array value [true, 'boolean', false]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_boolean_invalid_string_with_http_info(custom_headers = nil)
      get_boolean_invalid_string_async(custom_headers).value!
    end

    #
    # Get boolean array value [true, 'boolean', false]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_boolean_invalid_string_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/boolean/true.boolean.false'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'BooleanElementType',
                    type: {
                      name: 'Boolean'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get integer array value [1, -1, 3, 300]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_integer_valid(custom_headers = nil)
      response = get_integer_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get integer array value [1, -1, 3, 300]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_integer_valid_with_http_info(custom_headers = nil)
      get_integer_valid_async(custom_headers).value!
    end

    #
    # Get integer array value [1, -1, 3, 300]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_integer_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/integer/1.-1.3.300'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'NumberElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value empty [1, -1, 3, 300]
    #
    # @param array_body [Array<Integer>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_integer_valid(array_body, custom_headers = nil)
      response = put_integer_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value empty [1, -1, 3, 300]
    #
    # @param array_body [Array<Integer>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_integer_valid_with_http_info(array_body, custom_headers = nil)
      put_integer_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value empty [1, -1, 3, 300]
    #
    # @param array_body [Array<Integer>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_integer_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'NumberElementType',
              type: {
                name: 'Number'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/integer/1.-1.3.300'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get integer array value [1, null, 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_int_invalid_null(custom_headers = nil)
      response = get_int_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get integer array value [1, null, 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_int_invalid_null_with_http_info(custom_headers = nil)
      get_int_invalid_null_async(custom_headers).value!
    end

    #
    # Get integer array value [1, null, 0]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_int_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/integer/1.null.zero'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'NumberElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get integer array value [1, 'integer', 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_int_invalid_string(custom_headers = nil)
      response = get_int_invalid_string_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get integer array value [1, 'integer', 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_int_invalid_string_with_http_info(custom_headers = nil)
      get_int_invalid_string_async(custom_headers).value!
    end

    #
    # Get integer array value [1, 'integer', 0]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_int_invalid_string_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/integer/1.integer.0'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'NumberElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get integer array value [1, -1, 3, 300]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_long_valid(custom_headers = nil)
      response = get_long_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get integer array value [1, -1, 3, 300]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_long_valid_with_http_info(custom_headers = nil)
      get_long_valid_async(custom_headers).value!
    end

    #
    # Get integer array value [1, -1, 3, 300]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_long_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/long/1.-1.3.300'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'BignumElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value empty [1, -1, 3, 300]
    #
    # @param array_body [Array<Integer>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_long_valid(array_body, custom_headers = nil)
      response = put_long_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value empty [1, -1, 3, 300]
    #
    # @param array_body [Array<Integer>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_long_valid_with_http_info(array_body, custom_headers = nil)
      put_long_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value empty [1, -1, 3, 300]
    #
    # @param array_body [Array<Integer>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_long_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'BignumElementType',
              type: {
                name: 'Number'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/long/1.-1.3.300'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get long array value [1, null, 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_long_invalid_null(custom_headers = nil)
      response = get_long_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get long array value [1, null, 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_long_invalid_null_with_http_info(custom_headers = nil)
      get_long_invalid_null_async(custom_headers).value!
    end

    #
    # Get long array value [1, null, 0]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_long_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/long/1.null.zero'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'BignumElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get long array value [1, 'integer', 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_long_invalid_string(custom_headers = nil)
      response = get_long_invalid_string_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get long array value [1, 'integer', 0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_long_invalid_string_with_http_info(custom_headers = nil)
      get_long_invalid_string_async(custom_headers).value!
    end

    #
    # Get long array value [1, 'integer', 0]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_long_invalid_string_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/long/1.integer.0'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'BignumElementType',
                    type: {
                      name: 'Number'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get float array value [0, -0.01, 1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_float_valid(custom_headers = nil)
      response = get_float_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get float array value [0, -0.01, 1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_float_valid_with_http_info(custom_headers = nil)
      get_float_valid_async(custom_headers).value!
    end

    #
    # Get float array value [0, -0.01, 1.2e20]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_float_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/float/0--0.01-1.2e20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'FloatElementType',
                    type: {
                      name: 'Double'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value [0, -0.01, 1.2e20]
    #
    # @param array_body [Array<Float>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_float_valid(array_body, custom_headers = nil)
      response = put_float_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value [0, -0.01, 1.2e20]
    #
    # @param array_body [Array<Float>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_float_valid_with_http_info(array_body, custom_headers = nil)
      put_float_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value [0, -0.01, 1.2e20]
    #
    # @param array_body [Array<Float>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_float_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'FloatElementType',
              type: {
                name: 'Double'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/float/0--0.01-1.2e20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get float array value [0.0, null, -1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_float_invalid_null(custom_headers = nil)
      response = get_float_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get float array value [0.0, null, -1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_float_invalid_null_with_http_info(custom_headers = nil)
      get_float_invalid_null_async(custom_headers).value!
    end

    #
    # Get float array value [0.0, null, -1.2e20]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_float_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/float/0.0-null-1.2e20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'FloatElementType',
                    type: {
                      name: 'Double'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get boolean array value [1.0, 'number', 0.0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_float_invalid_string(custom_headers = nil)
      response = get_float_invalid_string_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get boolean array value [1.0, 'number', 0.0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_float_invalid_string_with_http_info(custom_headers = nil)
      get_float_invalid_string_async(custom_headers).value!
    end

    #
    # Get boolean array value [1.0, 'number', 0.0]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_float_invalid_string_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/float/1.number.0'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'FloatElementType',
                    type: {
                      name: 'Double'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get float array value [0, -0.01, 1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_double_valid(custom_headers = nil)
      response = get_double_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get float array value [0, -0.01, 1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_double_valid_with_http_info(custom_headers = nil)
      get_double_valid_async(custom_headers).value!
    end

    #
    # Get float array value [0, -0.01, 1.2e20]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_double_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/double/0--0.01-1.2e20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'FloatElementType',
                    type: {
                      name: 'Double'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value [0, -0.01, 1.2e20]
    #
    # @param array_body [Array<Float>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_double_valid(array_body, custom_headers = nil)
      response = put_double_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value [0, -0.01, 1.2e20]
    #
    # @param array_body [Array<Float>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_double_valid_with_http_info(array_body, custom_headers = nil)
      put_double_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value [0, -0.01, 1.2e20]
    #
    # @param array_body [Array<Float>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_double_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'FloatElementType',
              type: {
                name: 'Double'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/double/0--0.01-1.2e20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get float array value [0.0, null, -1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_double_invalid_null(custom_headers = nil)
      response = get_double_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get float array value [0.0, null, -1.2e20]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_double_invalid_null_with_http_info(custom_headers = nil)
      get_double_invalid_null_async(custom_headers).value!
    end

    #
    # Get float array value [0.0, null, -1.2e20]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_double_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/double/0.0-null-1.2e20'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'FloatElementType',
                    type: {
                      name: 'Double'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get boolean array value [1.0, 'number', 0.0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_double_invalid_string(custom_headers = nil)
      response = get_double_invalid_string_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get boolean array value [1.0, 'number', 0.0]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_double_invalid_string_with_http_info(custom_headers = nil)
      get_double_invalid_string_async(custom_headers).value!
    end

    #
    # Get boolean array value [1.0, 'number', 0.0]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_double_invalid_string_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/double/1.number.0'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'FloatElementType',
                    type: {
                      name: 'Double'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get string array value ['foo1', 'foo2', 'foo3']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_string_valid(custom_headers = nil)
      response = get_string_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get string array value ['foo1', 'foo2', 'foo3']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_string_valid_with_http_info(custom_headers = nil)
      get_string_valid_async(custom_headers).value!
    end

    #
    # Get string array value ['foo1', 'foo2', 'foo3']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_string_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/string/foo1.foo2.foo3'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'StringElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value ['foo1', 'foo2', 'foo3']
    #
    # @param array_body [Array<String>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_string_valid(array_body, custom_headers = nil)
      response = put_string_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value ['foo1', 'foo2', 'foo3']
    #
    # @param array_body [Array<String>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_string_valid_with_http_info(array_body, custom_headers = nil)
      put_string_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value ['foo1', 'foo2', 'foo3']
    #
    # @param array_body [Array<String>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_string_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'StringElementType',
              type: {
                name: 'String'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/string/foo1.foo2.foo3'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get string array value ['foo', null, 'foo2']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_string_with_null(custom_headers = nil)
      response = get_string_with_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get string array value ['foo', null, 'foo2']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_string_with_null_with_http_info(custom_headers = nil)
      get_string_with_null_async(custom_headers).value!
    end

    #
    # Get string array value ['foo', null, 'foo2']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_string_with_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/string/foo.null.foo2'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'StringElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get string array value ['foo', 123, 'foo2']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_string_with_invalid(custom_headers = nil)
      response = get_string_with_invalid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get string array value ['foo', 123, 'foo2']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_string_with_invalid_with_http_info(custom_headers = nil)
      get_string_with_invalid_async(custom_headers).value!
    end

    #
    # Get string array value ['foo', 123, 'foo2']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_string_with_invalid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/string/foo.123.foo2'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'StringElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652',
    # 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
    # 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_uuid_valid(custom_headers = nil)
      response = get_uuid_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652',
    # 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
    # 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_uuid_valid_with_http_info(custom_headers = nil)
      get_uuid_valid_async(custom_headers).value!
    end

    #
    # Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652',
    # 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
    # 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_uuid_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/uuid/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'UuidElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652',
    # 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
    # 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
    #
    # @param array_body
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_uuid_valid(array_body, custom_headers = nil)
      response = put_uuid_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652',
    # 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
    # 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
    #
    # @param array_body
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_uuid_valid_with_http_info(array_body, custom_headers = nil)
      put_uuid_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652',
    # 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
    # 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
    #
    # @param array_body
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_uuid_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'UuidElementType',
              type: {
                name: 'String'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/uuid/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_uuid_invalid_chars(custom_headers = nil)
      response = get_uuid_invalid_chars_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_uuid_invalid_chars_with_http_info(custom_headers = nil)
      get_uuid_invalid_chars_async(custom_headers).value!
    end

    #
    # Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_uuid_invalid_chars_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/uuid/invalidchars'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'UuidElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_valid(custom_headers = nil)
      response = get_date_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_valid_with_http_info(custom_headers = nil)
      get_date_valid_async(custom_headers).value!
    end

    #
    # Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateElementType',
                    type: {
                      name: 'Date'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value  ['2000-12-01', '1980-01-02', '1492-10-12']
    #
    # @param array_body [Array<Date>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_date_valid(array_body, custom_headers = nil)
      response = put_date_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value  ['2000-12-01', '1980-01-02', '1492-10-12']
    #
    # @param array_body [Array<Date>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_date_valid_with_http_info(array_body, custom_headers = nil)
      put_date_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value  ['2000-12-01', '1980-01-02', '1492-10-12']
    #
    # @param array_body [Array<Date>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_date_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'DateElementType',
              type: {
                name: 'Date'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/date/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get date array value ['2012-01-01', null, '1776-07-04']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_invalid_null(custom_headers = nil)
      response = get_date_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get date array value ['2012-01-01', null, '1776-07-04']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_invalid_null_with_http_info(custom_headers = nil)
      get_date_invalid_null_async(custom_headers).value!
    end

    #
    # Get date array value ['2012-01-01', null, '1776-07-04']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date/invalidnull'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateElementType',
                    type: {
                      name: 'Date'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get date array value ['2011-03-22', 'date']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_invalid_chars(custom_headers = nil)
      response = get_date_invalid_chars_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get date array value ['2011-03-22', 'date']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_invalid_chars_with_http_info(custom_headers = nil)
      get_date_invalid_chars_async(custom_headers).value!
    end

    #
    # Get date array value ['2011-03-22', 'date']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_invalid_chars_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date/invalidchars'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateElementType',
                    type: {
                      name: 'Date'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get date-time array value ['2000-12-01t00:00:01z',
    # '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_time_valid(custom_headers = nil)
      response = get_date_time_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get date-time array value ['2000-12-01t00:00:01z',
    # '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_time_valid_with_http_info(custom_headers = nil)
      get_date_time_valid_async(custom_headers).value!
    end

    #
    # Get date-time array value ['2000-12-01t00:00:01z',
    # '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_time_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date-time/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateTimeElementType',
                    type: {
                      name: 'DateTime'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00',
    # '1492-10-12T10:15:01-08:00']
    #
    # @param array_body [Array<DateTime>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_date_time_valid(array_body, custom_headers = nil)
      response = put_date_time_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00',
    # '1492-10-12T10:15:01-08:00']
    #
    # @param array_body [Array<DateTime>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_date_time_valid_with_http_info(array_body, custom_headers = nil)
      put_date_time_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00',
    # '1492-10-12T10:15:01-08:00']
    #
    # @param array_body [Array<DateTime>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_date_time_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'DateTimeElementType',
              type: {
                name: 'DateTime'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/date-time/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get date array value ['2000-12-01t00:00:01z', null]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_time_invalid_null(custom_headers = nil)
      response = get_date_time_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get date array value ['2000-12-01t00:00:01z', null]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_time_invalid_null_with_http_info(custom_headers = nil)
      get_date_time_invalid_null_async(custom_headers).value!
    end

    #
    # Get date array value ['2000-12-01t00:00:01z', null]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_time_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date-time/invalidnull'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateTimeElementType',
                    type: {
                      name: 'DateTime'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get date array value ['2000-12-01t00:00:01z', 'date-time']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_time_invalid_chars(custom_headers = nil)
      response = get_date_time_invalid_chars_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get date array value ['2000-12-01t00:00:01z', 'date-time']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_time_invalid_chars_with_http_info(custom_headers = nil)
      get_date_time_invalid_chars_async(custom_headers).value!
    end

    #
    # Get date array value ['2000-12-01t00:00:01z', 'date-time']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_time_invalid_chars_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date-time/invalidchars'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateTimeElementType',
                    type: {
                      name: 'DateTime'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980
    # 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_date_time_rfc1123valid(custom_headers = nil)
      response = get_date_time_rfc1123valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980
    # 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_date_time_rfc1123valid_with_http_info(custom_headers = nil)
      get_date_time_rfc1123valid_async(custom_headers).value!
    end

    #
    # Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980
    # 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_date_time_rfc1123valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/date-time-rfc1123/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DateTimeElementType',
                    type: {
                      name: 'DateTimeRfc1123'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35
    # GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
    #
    # @param array_body [Array<DateTime>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_date_time_rfc1123valid(array_body, custom_headers = nil)
      response = put_date_time_rfc1123valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35
    # GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
    #
    # @param array_body [Array<DateTime>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_date_time_rfc1123valid_with_http_info(array_body, custom_headers = nil)
      put_date_time_rfc1123valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35
    # GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
    #
    # @param array_body [Array<DateTime>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_date_time_rfc1123valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'DateTimeElementType',
              type: {
                name: 'DateTimeRfc1123'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/date-time-rfc1123/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_duration_valid(custom_headers = nil)
      response = get_duration_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_duration_valid_with_http_info(custom_headers = nil)
      get_duration_valid_async(custom_headers).value!
    end

    #
    # Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_duration_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/duration/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DurationElementType',
                    type: {
                      name: 'TimeSpan'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S']
    #
    # @param array_body [Array<Duration>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_duration_valid(array_body, custom_headers = nil)
      response = put_duration_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S']
    #
    # @param array_body [Array<Duration>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_duration_valid_with_http_info(array_body, custom_headers = nil)
      put_duration_valid_async(array_body, custom_headers).value!
    end

    #
    # Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S']
    #
    # @param array_body [Array<Duration>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_duration_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'DurationElementType',
              type: {
                name: 'TimeSpan'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/duration/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with
    # each item encoded in base64
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_byte_valid(custom_headers = nil)
      response = get_byte_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with
    # each item encoded in base64
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_byte_valid_with_http_info(custom_headers = nil)
      get_byte_valid_async(custom_headers).value!
    end

    #
    # Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with
    # each item encoded in base64
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_byte_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/byte/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'ByteArray'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with
    # each elementencoded in base 64
    #
    # @param array_body [Array<Array<Integer>>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_byte_valid(array_body, custom_headers = nil)
      response = put_byte_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with
    # each elementencoded in base 64
    #
    # @param array_body [Array<Array<Integer>>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_byte_valid_with_http_info(array_body, custom_headers = nil)
      put_byte_valid_async(array_body, custom_headers).value!
    end

    #
    # Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with
    # each elementencoded in base 64
    #
    # @param array_body [Array<Array<Integer>>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_byte_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'ArrayElementType',
              type: {
                name: 'ByteArray'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/prim/byte/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get byte array value [hex(AB, AC, AD), null] with the first item base64
    # encoded
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_byte_invalid_null(custom_headers = nil)
      response = get_byte_invalid_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get byte array value [hex(AB, AC, AD), null] with the first item base64
    # encoded
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_byte_invalid_null_with_http_info(custom_headers = nil)
      get_byte_invalid_null_async(custom_headers).value!
    end

    #
    # Get byte array value [hex(AB, AC, AD), null] with the first item base64
    # encoded
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_byte_invalid_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/byte/invalidnull'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'ByteArray'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get array value ['a string that gets encoded with base64url', 'test string'
    # 'Lorem ipsum'] with the items base64url encoded
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_base64url(custom_headers = nil)
      response = get_base64url_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get array value ['a string that gets encoded with base64url', 'test string'
    # 'Lorem ipsum'] with the items base64url encoded
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_base64url_with_http_info(custom_headers = nil)
      get_base64url_async(custom_headers).value!
    end

    #
    # Get array value ['a string that gets encoded with base64url', 'test string'
    # 'Lorem ipsum'] with the items base64url encoded
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_base64url_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/prim/base64url/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'StringElementType',
                    type: {
                      name: 'Base64Url'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get array of complex type null value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_complex_null(custom_headers = nil)
      response = get_complex_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get array of complex type null value
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_complex_null_with_http_info(custom_headers = nil)
      get_complex_null_async(custom_headers).value!
    end

    #
    # Get array of complex type null value
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_complex_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/complex/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ProductElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Product'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get empty array of complex type []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_complex_empty(custom_headers = nil)
      response = get_complex_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get empty array of complex type []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_complex_empty_with_http_info(custom_headers = nil)
      get_complex_empty_async(custom_headers).value!
    end

    #
    # Get empty array of complex type []
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_complex_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/complex/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ProductElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Product'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get array of complex type with null item [{'integer': 1 'string': '2'}, null,
    # {'integer': 5, 'string': '6'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_complex_item_null(custom_headers = nil)
      response = get_complex_item_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get array of complex type with null item [{'integer': 1 'string': '2'}, null,
    # {'integer': 5, 'string': '6'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_complex_item_null_with_http_info(custom_headers = nil)
      get_complex_item_null_async(custom_headers).value!
    end

    #
    # Get array of complex type with null item [{'integer': 1 'string': '2'}, null,
    # {'integer': 5, 'string': '6'}]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_complex_item_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/complex/itemnull'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ProductElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Product'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get array of complex type with empty item [{'integer': 1 'string': '2'}, {},
    # {'integer': 5, 'string': '6'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_complex_item_empty(custom_headers = nil)
      response = get_complex_item_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get array of complex type with empty item [{'integer': 1 'string': '2'}, {},
    # {'integer': 5, 'string': '6'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_complex_item_empty_with_http_info(custom_headers = nil)
      get_complex_item_empty_async(custom_headers).value!
    end

    #
    # Get array of complex type with empty item [{'integer': 1 'string': '2'}, {},
    # {'integer': 5, 'string': '6'}]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_complex_item_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/complex/itemempty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ProductElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Product'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3,
    # 'string': '4'}, {'integer': 5, 'string': '6'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_complex_valid(custom_headers = nil)
      response = get_complex_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3,
    # 'string': '4'}, {'integer': 5, 'string': '6'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_complex_valid_with_http_info(custom_headers = nil)
      get_complex_valid_async(custom_headers).value!
    end

    #
    # Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3,
    # 'string': '4'}, {'integer': 5, 'string': '6'}]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_complex_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/complex/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ProductElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Product'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Put an array of complex type with values [{'integer': 1 'string': '2'},
    # {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
    #
    # @param array_body [Array<Product>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_complex_valid(array_body, custom_headers = nil)
      response = put_complex_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Put an array of complex type with values [{'integer': 1 'string': '2'},
    # {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
    #
    # @param array_body [Array<Product>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_complex_valid_with_http_info(array_body, custom_headers = nil)
      put_complex_valid_async(array_body, custom_headers).value!
    end

    #
    # Put an array of complex type with values [{'integer': 1 'string': '2'},
    # {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
    #
    # @param array_body [Array<Product>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_complex_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'ProductElementType',
              type: {
                name: 'Composite',
                class_name: 'Product'
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/complex/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get a null array
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_array_null(custom_headers = nil)
      response = get_array_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get a null array
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_array_null_with_http_info(custom_headers = nil)
      get_array_null_async(custom_headers).value!
    end

    #
    # Get a null array
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_array_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/array/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'Sequence',
                      element: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an empty array []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_array_empty(custom_headers = nil)
      response = get_array_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an empty array []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_array_empty_with_http_info(custom_headers = nil)
      get_array_empty_async(custom_headers).value!
    end

    #
    # Get an empty array []
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_array_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/array/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'Sequence',
                      element: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_array_item_null(custom_headers = nil)
      response = get_array_item_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_array_item_null_with_http_info(custom_headers = nil)
      get_array_item_null_async(custom_headers).value!
    end

    #
    # Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_array_item_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/array/itemnull'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'Sequence',
                      element: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_array_item_empty(custom_headers = nil)
      response = get_array_item_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_array_item_empty_with_http_info(custom_headers = nil)
      get_array_item_empty_async(custom_headers).value!
    end

    #
    # Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_array_item_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/array/itemempty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'Sequence',
                      element: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7',
    # '8', '9']]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_array_valid(custom_headers = nil)
      response = get_array_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7',
    # '8', '9']]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_array_valid_with_http_info(custom_headers = nil)
      get_array_valid_async(custom_headers).value!
    end

    #
    # Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7',
    # '8', '9']]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_array_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/array/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'ArrayElementType',
                    type: {
                      name: 'Sequence',
                      element: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7',
    # '8', '9']]
    #
    # @param array_body [Array<Array<String>>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_array_valid(array_body, custom_headers = nil)
      response = put_array_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7',
    # '8', '9']]
    #
    # @param array_body [Array<Array<String>>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_array_valid_with_http_info(array_body, custom_headers = nil)
      put_array_valid_async(array_body, custom_headers).value!
    end

    #
    # Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7',
    # '8', '9']]
    #
    # @param array_body [Array<Array<String>>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_array_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'ArrayElementType',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'StringElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/array/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # Get an array of Dictionaries with value null
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dictionary_null(custom_headers = nil)
      response = get_dictionary_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of Dictionaries with value null
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dictionary_null_with_http_info(custom_headers = nil)
      get_dictionary_null_async(custom_headers).value!
    end

    #
    # Get an array of Dictionaries with value null
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dictionary_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/dictionary/null'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'HashElementType',
                    type: {
                      name: 'Dictionary',
                      value: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of Dictionaries of type <string, string> with value []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dictionary_empty(custom_headers = nil)
      response = get_dictionary_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of Dictionaries of type <string, string> with value []
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dictionary_empty_with_http_info(custom_headers = nil)
      get_dictionary_empty_async(custom_headers).value!
    end

    #
    # Get an array of Dictionaries of type <string, string> with value []
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dictionary_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/dictionary/empty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'HashElementType',
                    type: {
                      name: 'Dictionary',
                      value: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9':
    # 'nine'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dictionary_item_null(custom_headers = nil)
      response = get_dictionary_item_null_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9':
    # 'nine'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dictionary_item_null_with_http_info(custom_headers = nil)
      get_dictionary_item_null_async(custom_headers).value!
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9':
    # 'nine'}]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dictionary_item_null_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/dictionary/itemnull'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'HashElementType',
                    type: {
                      name: 'Dictionary',
                      value: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9':
    # 'nine'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dictionary_item_empty(custom_headers = nil)
      response = get_dictionary_item_empty_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9':
    # 'nine'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dictionary_item_empty_with_http_info(custom_headers = nil)
      get_dictionary_item_empty_async(custom_headers).value!
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9':
    # 'nine'}]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dictionary_item_empty_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/dictionary/itemempty'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'HashElementType',
                    type: {
                      name: 'Dictionary',
                      value: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'},
    # {'7': 'seven', '8': 'eight', '9': 'nine'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dictionary_valid(custom_headers = nil)
      response = get_dictionary_valid_async(custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'},
    # {'7': 'seven', '8': 'eight', '9': 'nine'}]
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dictionary_valid_with_http_info(custom_headers = nil)
      get_dictionary_valid_async(custom_headers).value!
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'},
    # {'7': 'seven', '8': 'eight', '9': 'nine'}]
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dictionary_valid_async(custom_headers = nil)


      request_headers = {}
      path_template = 'array/dictionary/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'HashElementType',
                    type: {
                      name: 'Dictionary',
                      value: {
                          required: false,
                          serialized_name: 'StringElementType',
                          type: {
                            name: 'String'
                          }
                      }
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'},
    # {'7': 'seven', '8': 'eight', '9': 'nine'}]
    #
    # @param array_body [Array<Hash{String => String}>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def put_dictionary_valid(array_body, custom_headers = nil)
      response = put_dictionary_valid_async(array_body, custom_headers).value!
      nil
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'},
    # {'7': 'seven', '8': 'eight', '9': 'nine'}]
    #
    # @param array_body [Array<Hash{String => String}>]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def put_dictionary_valid_with_http_info(array_body, custom_headers = nil)
      put_dictionary_valid_async(array_body, custom_headers).value!
    end

    #
    # Get an array of Dictionaries of type <string, string> with value [{'1':
    # 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'},
    # {'7': 'seven', '8': 'eight', '9': 'nine'}]
    #
    # @param array_body [Array<Hash{String => String}>]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def put_dictionary_valid_async(array_body, custom_headers = nil)
      fail ArgumentError, 'array_body is nil' if array_body.nil?


      request_headers = {}

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'arrayBody',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serialized_name: 'HashElementType',
              type: {
                name: 'Dictionary',
                value: {
                    required: false,
                    serialized_name: 'StringElementType',
                    type: {
                      name: 'String'
                    }
                }
              }
          }
        }
      }
      request_content = @client.serialize(request_mapper,  array_body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'array/dictionary/valid'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

  end
end
